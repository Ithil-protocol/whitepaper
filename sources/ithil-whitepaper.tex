\documentclass[a4paper,10 pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{}
\usepackage{amsmath, amssymb, amsthm}

\usepackage[dvipsnames]{xcolor}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{problem}{Problem}

\newcommand{\tb}{\verb|TKB|}
\newcommand{\ta}{\verb|TKA|}

\theoremstyle{definition}
\newtheorem{remark}{Remark}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}

\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
            
        \Huge
        \textbf{Ithil}

        \vspace{0.5cm}
        \Large
        {\bf The Web3 Wizard}

        \vspace{1cm}
        \Large
        {\it Ithil is a speculation primitive and core building layer that facilitates the creation of novel financial services.}

        \vspace{1.5cm}
        {\normalsize V2.0.1 - \today}
        \vspace{1.0cm}

        \begin{abstract}        
        Ithil aims to become the base layer for decentralised financial services via a well-thought system of composable smart contracts, paired with liquidity vaults to issue debit or credit to.
        
        Modular and easily upgradable, Ithil offers users and other protocols composable, audited lego blocks, enabling an entirely new range of financial opportunities to be created. External protocols can speed up their go-to-market by having an existing infrastructure and access to liquidity from day 1, investors can find novel solutions to speculate on and lenders can get diversifie exposure to the whole web3 space from a single platform.
        \end{abstract}
            
    \end{center}
\tableofcontents
\end{titlepage}

\section{Introduction}

In the current Web3 space there are several opportunities, from DeFi high yields to NFTs and Real World Assets (RWA), with new ones coming up almost every day. Users are shown a wide landscape to interact with, depending on their risk appetite and personal ideas. However, all the subspaces are set apart one another, and end up being self-contained bubbles that don't interact with each other: DeFi, NFTs, RWA and metaverse are all separate from each other and the composability of one another is still uncharted territory.

While for the lenders, the typical parameters LPs look for are a good APY, the market exposure (such as by holding volatile tokens), the underlying protocol's reliability and security, the liquidity available or TVL, their personal preferences and several other factors difficult to predict or model.
With Ithil they are presented a novel opportunity to get exposed to the high yields on the whole Web3 space in a combined way, reducing the overall risk as well as increasing the return rates on their deposits.

\subsection{What is Ithil}
%At its core, Ithil is a protocol that combines the liquidity providers' deposits to other protocols to create novel financial services for its users. In this way, Ithil can be considered as a {\it trait-d'union} between the many protocols existing in the space, users and liquidity providers.

At its core, Ithil is a protocol allowing {\it liquidity providers} to deposit their assets, and {\it users} to deploy such assets into external protocols within the Web3 world. Users need to protect the LPs' assets by placing some {\it collateral} and by paying {\it interests} on the deployed liquidity. 
In this way, LPs benefit of a very low risk and a solid return thanks to a high diversification and capital protection, while users are entitled to all earnings and services coming from the deployed assets.

\subsection{What can be done on Ithil}
With Ithil, anyone can
\begin{enumerate}
\item Become {\bf liquidity provider} (LP) by depositing their assets to get a solid APY. A extensive choice of whitelisted tokens can be staked in Ithil, and the APY generated is in the same token as the provided one. In this way, Ithil offers an attractive staking opportunity, also for holders of volatile tokens.
\item Boost their investments by placing some collateral and then using the LP liquidity on one of Ithil's whitelisted protocols (Aave, Uniswap, Balancer, OpenSea etc...). Thanks to an internal system of undercollateralised loans (the {\bf Internal Lending Engine}), the total capital deployed can be much higher than the collateral placed: by placing only 100 DAI worth of collateral, a user can deploy 1000 DAI worth of liquidity or more.
\item Be a {\bf liquidator} by constantly checking open positions and liquidating thoe at loss in a fully decentralised way.
\item Become an {\bf automator} by performing farming or other maintenance duties on the services which require them and getting a reward for that.
\item Join the {\bf community} by holding and staking Ithil governance token, to take part in the protocol governance, earn part of the fees or trade.
\end{enumerate}

\subsection{Ithil's unique features}
Many of Ithil features are scattered around the current web3 landscape and need users to combine multiple protocols to achieve the same result. Some of the differences are the following:
\begin{itemize}
\item {\bf Modularity} allows Ithil to list or de-list virtually any service with a governance vote, hence continuously updating the services offered integrating the most recent protocols, always featuring what is best and trending, be it DeFi, Metaverse, Play to Earn or anything.
\item {\bf High capital efficiency} over-collateralisation has always been an essential aspect in DeFi loans, which reduces the possibility for users to leverage their available funds.\footnote{Or makes this process very costly, mainly through the so-called {\it folding strategies} on money markets like Aave.} Thanks to a novel lending model, Ithil makes it possible to protect the loans with just the right amount of capital, thus allowing a completely new set of speculative financial services.
\item {\bf Opportunity to earn from virtually any token}: few protocols offer a single-sided APY on ideally any token, usually being restricted to stablecoins, high market cap tokens like WBTC and WETH or the protocol native token. Ithil lending vaults are instead token-agnostic: any ERC20 token can be whitelisted and lent, collecting fees in that same token.
\item {\bf Real-yield sustainable fee redistribution} thanks to a sustainable treasury management and a non-dilutive TVL boosting system.
\item {\bf Capital protection} for liquidity providers: an efficient liquidation model and proper risk tranching protect LPs' liquidity, thus assuring hedged earnings with limited risk exposure.
\end{itemize}

\subsection{The Vision}
Ithil main aim is to offer the broadest range of decentralised financial services for the web3 users and help get the most out of them.

By interconnecting the several protocols existing in the different niches of web3, Ithil can create innovative speculation opportunities (DeFi strategies), help users obtain what they want (on-chain mortgages) or simply have fun.

Through leverage, Ithil wants to mitigate the intrinsic advantage of wealthy individuals, allowing everyday people to fully embrace any opportunity web3 has to offer.

Building trust is a primary goal, especially in an ecosystem where scammers, Ponzi schemes, and ill-modelled speculative systems are unfortunately very popular. Ithil commits to giving real value to the community: every surplus earned by the protocol is algoritmically distributed to the token holders, thus increasing the value of the governance token and the financial power of its treasury in a simple and sustainable way.

\newpage

\section{Core concepts}
This section summarises the inner workings of the protocol, which will be treated more in-depth in the following sections. 

\subsection{Ithil's core}\label{coreSub}

At its core, Ithil is just a framework to algorithmically distribute risk and capital following the market's demands. It consists of a set of {\bf Vaults} containing the capital, and a {\bf Manager} Smart Contract coordinating the Vaults and the Services (see \ref{servicesSub}).

\subsubsection{The Vaults}\label{vaultSubSub}
The {\bf Vaults} are ERC4626 smart contracts that collect liquidity to be used in services required by the users. The liquidity contained in each Vault is made of an {\bf ERC20 token}, which can be in principle any token, from stablecoin to meme and rebasing tokens. 
Every Vault is deployed and owned by the Manager (see \ref{managerSubSub}).

{\bf Liquidity Providers (LPs)} can freely {\bf deposit} into the Vaults and {\bf withdraw} from them at any time. The Vault contract collects the fees generated by the Services, which increase the share price of the Vault's ERC4626 token thus yielding an APY to the LPs.

The Manager (see \ref{managerSubSub}) can {\bf borrow} and {\bf repay} the Vault's capital, as long as redistribute the shares by {\bf minting} and {\bf burning} the Vault ERC4626 token. Each Vault keeps record of all {\bf profits}, {\bf losses} as long as outstanding {\bf loans} via on-chain storage data.

\subsubsection{The Manager}\label{managerSubSub}

The {\bf Manager} is responsible for the coordination and cash flow between the Vaults and the Services. Only whitelisted addresses, called {\bf Services} (see \ref{servicesSub}) can call the borrow, repay, mint and burn functions of the Vault through the Manager. In particular, all non-view Manager's functions are either whitelisted or only-owner.

For every Service, the Manager stores its {\bf cap}, that is the maximum amount which can be borrowed, minted or burned by the Service. The Governance sets up the caps: an address with positive cap is equivalent to a whitelisted address.

Finally, the Manager deploys the Vaults (\ref{vaultSubSub}) via a Governance function.

\subsection{Services}\label{servicesSub}

Technically, a {\bf Service} is simply an address, which has a positive cap on the Manager and is open to non-governance users. Therefore, general users only use Services to interact with Ithil. This level of abstraction allows for extreme flexibility in the services provided, while the simplicity and rigidity of the Manager and the Vaults ensure a solid accounting and a safe echosystem.

In practice, a Service is a Smart Contract that offers a specific financial resource by interacting with the Vaults' liquidity to perform a certain action. Such Services can either be ``native" (developed by Ithil's development team itself) or even developed by external teams: the only need is that Ithil's Governance should approve them by setting a positive cap to their addresses (see \ref{managerSubSub}).

It is important to stress that Services are not part of Ithil's core: they are {\it components} which can be listed, de-listed and controlled using the Manager's caps. The range of possibilities of the various Services is immense, however we will outline in this document a suite of Services proposed by Ithil's team, which show how the team originally conceived the good usage of these components. The effort has been put in making these Services as modular as possible: different Services can be obtained by wisely combining existing pieces with a minimal extra development work.

\subsection{Ithil's Services suite}

Ithil's services are broadly divided into {\bf Debit Services (DS)} and {\bf Credit Services (CS)} depending on respectively whether the service itself needs to borrow from or lend liquidity to the Vault.

When {\bf entering an Agreement}, the user gets an {\bf agreement NFT} which represents the user's entitlement to a certain asset held in the service and the liquidity taken from, or given to, the Vaults. {\it The assets are locked in the Service contract until the loan is repaid.} See \ref{posNftSubSub} for further details about agreement NFTs.

When {\bf exiting an Agreement}, all the loans are extinguished, the due fees are paid to the Vault(s) and the agreement NFT is burned. The user gets any other assets remaining after the closure as profit.

An Agreement may require some {\bf automation}, that is actions taken by external operators who get rewards in doing so, to work correctly. The most important one is {\bf liquidation} for Debit Services; other types of automation include {\bf burning or minting shares} (typical of Credit Services) and {\bf harvesting} (both for Debit and Credit), but virtually any function called by a non-owner address can be considered an automation.

See \ref{servicesSec} for real examples of supported Services and Targets.

\subsubsection{Debit Services}\label{debitSubSub}
A {\bf Debit Service} is a contract which triggers one or more loans {\it from a Vault} and deploys the obtained liquidity to an combination of other contracts called {\bf Targets} (see \ref{targetsSub}). These targets are typically, but not necessarily, outside of Ithil: examples are OpenSea, a DeFi protocol, a created market, etc...

\subsubsection{Credit Services}\label{creditSubSub}
A {\bf Credit Service} is a contract that lends liquidity {\it to a Vault} and deploys the obtained ERC4626 LP token to another contract called {\bf Target} (see \ref{targetsSub}). These targets are typically, but not necessarily, within Ithil: examples are tranches, \$ITHIL Call and Put Options, bonds, etc... Typically, Credit Services need burn / mint automations.

\subsubsection{Agreement NFT}\label{posNftSubSub}

Every time a user interacts with a Service, an {\bf agreement NFT} representing the specific User-Service interaction is minted to the user wallet. The data contained depends on the particular service it refers to, but all services share some common parameters:
\begin{itemize}
\item The {\bf owner}, i.e. the address of the user entering the service.
\item The service {\bf name}.
\item The {\bf loan} amounts.
\item The type and number of assets held in the Service as {\bf collateral}.
\item The {\bf interest rate} of the loan taken or given.
\item The {\bf timestamp} of when the agreement was subscribed.
\item Some {\bf extra parameters} depending on the particular service.
\end{itemize}

\subsubsection{Quoter}\label{quoterSubSub}
A Debit Service must have its own {\bf quoter}, an on-chain function in charge of evaluating the capital health of each agreement. It is developed and part of the Service smart contract, so that each service has one and only one quoter.

By {\it evaluation} we mean the amount of Vault's tokens the user can obtain when exiting the agreement in that particular moment; this number is called the {\bf value} of the agreement NFT. This includes the Target's payoff in that moment and the  The value is used to compute the {\bf liquidation score} of an agreement NFT: if the liquidation score becomes positive, any {\bf liquidator} user (see \ref{liquidatorSub}) can trigger a special function of the Manager to forcefully close the position and repay the loan before it becomes insolvent. An extra fee is then applied to the user margin in order to compensate the liquidator.

\subsection{Fees}\label{feeSub}

Agreements may or may not have {\bf fees} attached. The fees are always deposited to a Vault and contribute to the appreciation of the ERC4626 token-shares representing the Vault deposits. Fees are paid when an agreement is {\it exited} but unlocked over time to prevent frontrunning attacks.

The fee structure of an agreement depend on the Service it refers to, in general we can identify three types of fees.

\subsubsection{Interest rate}\label{interestRateSubSub}
When liquidity is borrowed from a Vault, an {\bf interest rate} is applied to the loan. The calculation of the interest rate is performed by a separate {\bf interest rate contract} and the result depends on the global state of Ithil. As a rule of thumb, the interest rate increases proportionally to the Vault liquidity usage and to the overall amount of liquidity already locked in that Service, while it decreases with the amount of user's collateral and with elapsed time from latest interaction (as in a Dutch auction scheme). The proportionality coefficients are decided by the governance and vary for each token and each Service, therefore the actual determination of the interest rate depends on a mixed algorithmic + governance-provided set of parameters.

\subsubsection{Fixed fees}\label{fixedFeesSubSub}
When a Service is used, a {\bf fixed fee} might be charged to enter the Agreement. This fee may or may not depend on the amount of collateral posted or liquidity borrowed. The fixed fees are set by the governance.

\subsubsection{Performance fees}\label{fixedFeesSubSub}
Some Services (typically externally-created ones) may have a {\bf performance fee}, where percentage of the accrued profits goes to the Vault.

\subsection{Targets}\label{targetsSub}

By {\bf Target} we mean any contract to which borrowed or lent liquidity is deployed to. Targets, which can be either external or internal to Ithil ecosystem, represent the way anyone can use Ithil to access external services with more liquidity than their original (leverage), or internal services to get extra benefits from lending their liquidity to Ithil. See \ref{servicesSec} for real examples of supported Services and Targets.

\subsection{Automators}\label{automatorsSub}

{\bf Automators} are external players which perform various tasks in order to optimise the outcome of each Service, and get rewards by doing this. Everybody can be an automator and there is no entry cost nor staking requirement, since Ithil considers the automators' actions as beneficial to the ecosystem. 

As an example of automators we will talk about liquidators and harvesters.

\subsubsection{Liquidators}\label{liquidatorSubSub}
A {\bf liquidator} is anybody who makes an agreement with positive {\bf liquidation score} to be forcefully exited. In this case, the liquidator becomes the owner of the agreement and gets the remaining funds as a reward. In case no liquidity is left, LPs in junior tranches are charged for the liquidation rewards due. In this way, liquidators ensure the loans are repaid in the fastest way as possible: even if a loss is inevitable, liquidation will be quickly performed and minimise it.

\subsubsection{Automator}\label{automatorSubSub}
An {\bf automator} is anybody who triggers special functions to improve the performance of a Service and it is always rewarded using part of the extra value given to the Service. 

This abstract definition is better explained with examples (see Section \ref{servicesSec}). As mentioned above, all debit services have a very important automation: liquidation. If a {\it liquidation threshold} is reached for an Agreement, the liquidator can forcefully close it to repay the Vault and get rewarded with a liquidation fee. Other types of automation depend on the particular service.

\section{Examples of Services}\label{servicesSec}

Examples of Services, with the respective Targets and the way they work, are the following. The following examples are not intended to declare what Ithil actually chose or will choose to whitelist in the future, but rather to illustrate the possibilities of application of Ithil's infrastructure.

\subsection{Debit services}
These services are characterised by liquidity that goes {\it from} the Vault {\it to} the particular Service. In this case the Vault issues a loan to the Service by transferring the liquidity to the Service smart contract, which then locks any asset obtained. This loan is repaid when the agreement is exited.

\begin{itemize}
\item {\bf LP on Uniswap V3}. Liquidity is taken from one or two Vaults and deployed within a price range on Uniswap V3. The resulting UniV3 NFT is then locked into Ithil's agreement NFT. At the exit, the liquidity and generated fees are withdrawn from Uniswap NFT and the loan to the Vault is repaid.

\item {\bf NFT mortgages on OpenSea}. Liquidity is taken from a Vault to purchase an NFT from OpenSea, which is then locked into the agreement NFT. In order to keep the position open, the user must regularly inject liquidity into the Vault to partially repay the loan (this is an example of necessary automation: if the user does not perform it, liquidation occurs). At the exit, the loan is fully repaid and the original NFT is transferred to the user.

\item {\bf Public sales and market creation}. A liquidity pool for a token TKN is created as a Service, and funds are borrowed from a Vault to provide single-side liquidity to it; after that, trading is freely allowed on the pool (in this case, a swap performed by an external player can be seen as a form of automation). The final product of this process is a public sale of TKN and a market for it, except that purchasers benefit from the rest of Ithil's infrastructure such as insurance and boosting (see \ref{csFirstSec}). Any income coming from TKN in the form of rewards, dividends or other defines an additional automation of the Service.
\end{itemize}
\subsection{Credit services}\label{csFirstSec}

These services are characterized by liquidity that goes {\it to} the Vault {\it from} the particular service. In this case the User provides the liquidity to the Service smart contract, which then transfers it to the Vault and gets the resulting Vault's token. The token is then used for the Service particular functionalities and it is redeemed to the Vault when the agreement is exited.

\begin{itemize}
\item {\bf Tranching}. Automation as burn and mint allow for a simple way to define {\bf tranching} on the LPs' credit. Liquidity is deposited into a Vault and the resulting ERC4626 are redirected into one of the trancing Services (one for each tranch). Automators (see \ref{automatorSubSub}) burn and mint a certain amount, algorithmically defined, of ERC4626 tokens to the Service, which modify the claimable amount of the users with a reflection. If a mint occurs during a gain and a burn during a loss, we say that the Service is {\bf junior}, while then the converse occurs we say that it is {\bf senior}. Since junior Services have the effect of reintegrating a loss in the Vault, we call the users of junior credit {\it Insurers}; conversely, since senior Services have the effect of incrementing gains, we call users of senior credit {\it Boosters}.

\item {\bf LP'ing}. Regular LP'ing can be considered a "trivial" Credit Service, with intermediate seniority between Boosters (senior) and Insurers (junior).

\item {\bf Fixed yield}. In this Service, users deposit and get a fixed APY decided at the enter of the Agreement. Automators enforce this APY to be respected by minting extra tokens if the actual APY is too low, and by burning some if the APY is too high. Of course, one of the two sides (users of this Service and LPs) will lose and one will gain, depending on the particular condition of Ithil's usage.
\end{itemize}

\newpage
\section{The Vaults}\label{vaultSec}

We now look more deeply into the technical specifications of Ithil's Vaults. As mentioned in \ref{vaultSubSub}, the Vault is yield bearing token following the ERC4626 standard, and its purpose is collecting all liquidity deposited by LP's and Credit Services, and lending this liquidity to Debit Services.

First of all, the Vault inherits from ERC4626 and from OpenZeppelin's Ownable contract:
$$ \verb|contract Vault is ERC4626, Ownable| \  \ \{ \verb|...| \}$$
Since every Vault is deployed by the Manager contract (see \ref{managerSec}), this contract is the owner of all the Vaults.
We will not dig down into ERC4626 and Ownable's contract specification and redirect the interested reader into the respective contracts' documentations.

We will instead talk about Ithil's overrides to the inherited ERC4626 functions and Ithil's specific functions.

\subsection{Accounting}\label{accountingSub}
The Vault keeps three state variables for accounting: 
$$ \verb|uint256 netLoans|, \ \ \verb|uint256 currentProfits|, $$ $$\verb|uint256 currentLosses|, \ \ \verb|uint256 latestRepay|$$
The variable \verb|netLoans| registers the total amount of loans given across all Debit Services, while \verb|currentProfits| and  \verb|currentLosses| are the total {\it locked} profits and losses respectively, at the moment of the latest repay. The block's timestamp of the latest repay is registered into \verb|latestRepay|.

\subsection{Locking}\label{lockingSub}
Fees and losses (see \ref{repaySub}) undergo a locking period to dampen the movements of the Vault's token price per share and protect the Vault from flashloan attacks. The locked fees are computed via the \verb|calculateLockedProfits()| function, whose formula is
$$L = P\cdot\frac{(T_L+T_U-T)_+}{T_U} $$
where $L$ is the result of the function, $P$ is the \verb|currentProfits|, $T_U$ is the Vault's \verb|unlockTime|, a governance-decided variable initialized at 6 hours, $T_L$ is the \verb|latestRepay| and $T$ is the current block's timestamp. The subscript "$+$" indicates the positive part.

In particular, when $T = T_L$, that is at the moment of profit (or loss) generation, we have $L = P$ and all \verb|currentProfits| are locked. After the locking period, that is $T \ge T_L + T_U$, we will have $L=0$ so all fees are unlocked. For $T_L \le T \le T_L + T_U$, we have $$L = P\cdot\left(1- \frac{T - T_L}{T_U} \right)$$ meaning that the fees and the losses unlock {\it linearly} with time.

The function \verb|calculateLockedLosses()| does the exact same with the variable \verb|currentLosses| instead.

\subsection{Total Assets}\label{totalAssetsSub}

Both borrowing from the Vault and repaying would modify the value of \verb|totalAssets| as defined in the original ERC4626 contract and the resulting token price per share. Since loans are just temporarily moved from the vault, and since fees need to undergo a locking period, we need to factor this in into the definition of total assets. Therefore we have $$\verb|totalAssets| = \verb|super.totalAssets + netLoans +| $$ $$\verb| + calculateLockedLosses() - calculateLockedProfits()|$$ with the use of mathematical overflow and capping checks so that to always make \verb|totalAssets| $> 0$ and never make the above computation overflow (this is the recommended ERC4626 standard for overriding this function).

\subsection{Free Liquidity}\label{freeLiquidity}

The Free Liquidity is the amount of liquidity that can be freely borrowed or withdrawn. Of course, it would be impossible to transfer an amount higher than the Vault's native token balance, but also locked profits should not be available for borrowing or withdrawal. Therefore, letting $L = \verb|calculateLockedProfits()|$ we define
$$\verb|freeLiquidity| = \begin{cases}
\verb|native.balanceOf(vault)| - L &\text{ if } L > 0 \\

\verb|native.balanceOf(vault)| &\text{ otherwise}.
\end{cases} $$

Notice that locked losses are not added to this calculation, since that would give the possibility of borrowing lost assets, thus breaking the mathematical soundness of the Vault.

An important caveat is that {\it the entirety of the free liquidity cannot be borrowed or withdrawn at once}. Indeed, this could cause the Vault to become {\bf unhealthy} as per ERC4626 standard. Therefore, the functions \verb|borrow|, \verb|withdraw| and \verb|redeem| have a check so to revert if the entirety of the free liquidity is taken. 
\subsection{Borrow}\label{borrowSub}

The Vault's \verb|borrow(amount, receiver)| function is an only-owner function which directly transfers \verb|amount| of the native asset from the Vault to a \verb|receiver|. In order to register the loan, the \verb|netLoans| state variable is incremented by \verb|amount|. In practice, the receiver will be one of the whitelisted Debit Services, as the Router is in control of the list of receivers.

In order to insure the Vault is {\it healthy} as per ERC4626 standard (this means that the Vault's balance cannot be zero if the Vault's supply is higher than zero),  the \verb|amount| must be {\it strictly less} than the Vault's {\it free liquidity}.

The typical use case is liquidity lent to a Debit Service contract in order to make a user enter an Agreement.

By checking the formulas for \verb|totalAssets()|, we see that the \verb|borrow| function does not modify the total assets immediately after being called: the total assets are an {\it invariant} of the borrow function.
\subsection{Repay}\label{repaySub}

The Vault's \verb|repay(assets, debt, repayer)| function is an only-owner function which directly transfers \verb|assets| of the native asset from the \verb|repayer| to the Vault. The \verb|debt| is the amount of loan this function is declared to repay: the \verb|netLoans| state variable is decremented by \verb|debt| within this function.

The parameter \verb|assets| can be either larger or smaller than \verb|debt|. In the former case, we say that the difference \verb|assets - debt| is the {\bf fees} paid to the Vault for lending its liquidity; in the latter case, we say that the difference \verb|debt - assets| is the {\bf loss} incurred by the Vault for lending its liquidity. We call the former case a {\bf Good Repay Event (GRE)} and the latter case a {\bf Bad Repay Event (BRE)}. 

Both the fees and the losses undergo a {\bf locking period} which protects the Vault from flashloaners draining all the incoming fees and disincentivize LPs to frontrun losses. In order to do this, the \verb|currentProfits| and \verb|latestRepay| variables are updated as 
$$\verb|currentProfits| \mapsto \verb|calculateLockedProfits() + (assets - debt)|_+$$ 
$$\verb|currentLosses| \mapsto \verb|calculateLockedLosses() + (debt - assets)|_+$$ 
$$\verb|latestRepay| \mapsto \verb|block.timestamp|$$ 
where the "$+$" subscript stands for the positive part of the subtraction.

Notice that \verb|currentProfits| increases in a GRE, and the \verb|currentLosses| increases in a BRE. Since the Vault's total assets are the sum of profits and losses, good repays and bad repays can compensate each other.

As per ERC4626 standards, a high \verb|currentProfits| will tend to increase the Vault's token price per share, while a high \verb|currentLosses| will tend to decrease it.

The typical use case is to repay a loan when exiting an Agreement of a Debit Service contract.

By checking the formulas for \verb|totalAssets()| and locking, we see that the \verb|repay| function does not modify the total assets immediately after being called: the total assets are an {\it invariant} of the repay function.

\subsection{Direct mint}\label{directMint}
The Vault's \verb|directMint(shares,receiver)| function is an only-owner function which directly mints \verb|shares| of the Vault's ERC4626 tokens to the \verb|receiver|. In practice, the receiver will be one of the whitelisted Credit Services, as the Manager is in control of the list of receivers.

This function has the effect of decreasing the Vault's price per share, while distributing part of the Vault's assets to the receiver by reflection. In that sense, it is considered a {\it loss} for the Vault and as such it needs to undergo the usual locking period. In order to calculate the loss, we use the native ERC4626 \verb|convertToAssets| function and update 
$$\verb|currentProfits| \mapsto \verb|calculateLockedProfits()|$$ 
$$\verb|currentLosses| \mapsto \verb|calculateLockedLosses() + convertToAssets(shares)|$$ 
$$\verb|latestRepay| \mapsto \verb|block.timestamp|$$

The typical use case of this function is the distribution of part of the accrued fees to a Credit Service.

By checking the formulas for \verb|totalAssets()| and ignoring unlocking, we see that the \verb|directMint| function decreases the total assets immediately after being called. However, as long as currentProfits are positive, it is always possible to choose a value for \verb|shares| such that unlocking of profits compensate the distribution of fees to the receiver, so that the other lenders do not experience any decrease in their share value.

\subsection{Direct burn}\label{directBurn}
The Vault's \verb|directBurn(shares,owner)|  function is an only-owner function which burns \verb|shares| of the Vault's ERC4626 tokens to the \verb|owner|. In practice, the owner will be one of the whitelisted Credit Services, as the Manager is in control of the list of owners. In order for the burning to be successful, the owner must have approved the Vault to burn at least the amount of shares to be burned.

This function has the effect of increasing the Vault's price per share, while distributing part of the owner's assets to the Vault by reflection. In that sense, it is considered a {\it profit} for the Vault and as such it needs to undergo the usual locking period. In order to calculate the profit, we use the native ERC4626 \verb|convertToAssets| function and update 
$$\verb|currentProfits| \mapsto \verb|calculateLockedProfits() + convertToAssets(shares)|$$ 
$$\verb|currentLosses| \mapsto \verb|calculateLockedLosses()|$$ 
$$\verb|latestRepay| \mapsto \verb|block.timestamp|$$

The typical use case of this function is the return of part of the accrued fees from a Credit Service to the Vault.
By checking the formulas for \verb|totalAssets()| and ignoring unlocking, we see that the \verb|directBurn| function increases the total assets immediately after being called. The same unlocking reasoning as in \verb|directMint| apply to this function.

\newpage 
\section{Manager}\label{managerSec}
The {\bf Manager} is the contract in charge of managing cashflows and risk across the Vaults and the Services. The Manager is the also the deployer and owner of all the Vaults (in particular, it can call the borrow, repay, directMint and directBurn functions of the Vaults). By setting a nonzero {\bf cap}, the Manager can whitelist a given Service, while setting the {\bf risk spreads} the Manager defines the risk of each Service. In this way, Ithil can provide a complete risk management system easily scalable and with a full control of the various allocations.

The core of the Manager thus consists of two state variables:
$$\verb|mapping(address => address) vaults|$$
$$\verb|mapping(address => mapping(address => RiskParams)) riskParams|$$
where \verb|RiskParams| is a data structure containing the spreads and caps of each Service:
$$\verb|struct RiskParams = {uint256 cap, uint256 riskSpread}|$$

The \verb|vaults| mapping simply contains the Vault address for each underlying asset, while the \verb|riskParams| register the risk parameters of each Service address (first argument) for a given token (second argument).

\subsection{Manager's functions}
The Manager's function fall into two categories: onlyOwner functions and whitelisted functions.

The {\bf onlyOwner} functions can only be used by Ithil's governance and are the following:
\begin{itemize}
\item \verb|create(address token)|: deploys a new Vault with \verb|token| as underlying asset
\item \verb|setSpread(address service, address token, address spread)|: sets a spread in \verb|riskParams| for a given service and token
\item \verb|setCap(address service, address token, address spread)|: sets a cap in \verb|riskParams| for a given service and token
\end{itemize}

The {\bf whitelisted} functions can only be called by addresses whose \verb|cap| in \verb|riskParams| is positive.
\begin{itemize}
\item \verb|borrow(token, amount, exposure, receiver)|: calls the Vault's \verb|borrow| function and checks whether the new exposure (see \ref{servicesSec}) stays below the Service's cap for the particular \verb|token|. In the parameters, \verb|exposure| is the current exposure of the Service and it is stored in the Service itself and passed to the Manager. Since Services are whitelisted by the Governance (by setting a nonzero cap), we can assume the datum passed to the Manager as exposure is reliable.
\item \verb|repay(token, amount, debt, repaier)| calls the Vault's \verb|repay| function (no exposure checks are performed on this function).
\item \verb|directMint(token,to,shares,exposure)| calls the Vault's \verb|directMint| funciton and checks whether the new exposure (see \ref{servicesSec}) stays below the Service's cap for the particular \verb|token|.
\item \verb|directBurn(token,from,shares,exposure)| calls the Vault's \verb|directBurn| funciton and checks whether the new exposure (see \ref{servicesSec}) stays below the Service's cap for the particular \verb|token|.
\end{itemize}

\section{Services}\label{servicesSec}

The Manager allows any address with positive cap to borrow and repay the Vaults. Therefore, in theory, any address could be whitelisted. In practice, the Governance whitelists other Smart Contracts called {\bf Services}.

In principle, anybody can suggest a Service and submit it for approval by the Governance. Currently, Ithil developers have designed a suite of Smart Contracts, aiming to make the development of new Services as easy as possible, yet producing well-thought and secure ways to use the Vaults' liquidity. In this section, we describe this suite, while in the next section we discuss a few examples about how to apply this architecture in practice.

It is important to stress out that Ithil's core, consisting of the Manager and the Vaults, is agnostic of the functioning of the whitelisted contracts, therefore (as long as the Governance agrees), even a Service which does not respect the structure described below might be whitelisted in the future.

\subsection{Base Service}\label{baseServiceSub}
The {\bf Base Service} contract (also simply called \verb|Service|) is an abstract contract containing the basic functionality every Service must have in order to be whitelisted. The contract inheritance is as follows:
$$ \verb|abstract contract Service is Ownable, ERC721 {...|$$
In particular, it is minted as an NFT to the caller or the \verb|open| function. We call {\it user} the caller of this function, and we say that the user {\it enters an Agreement}.

\subsubsection{Storage and data structures}\label{dataStructureSubSub}
The main storage of the Service consists of two state variables:
$$\verb|mapping(address => uint256) exposures|$$
$$\verb|Agreement[] agreements|$$

The \verb|exposures| variable registers the sum of all loan amounts for a given token. This variable is passed to the Manager (see \ref{managerSec}) to enforce caps.

The \verb|agreements| is an array of data structures:
$$ \verb|struct Agreement = {Loan[] loans, Collateral[] collaterals,| $$ $$ \verb|uint256 createdAt, Status status}|$$
which in turn contains the data structures
$$ \verb|struct Loan = {address token, uint256 amount,| $$ $$  \verb|uint256 margin, uint256 interestAndSpread}|$$
and
$$ \verb|struct Collateral = {ItemType item, address token,| $$ $$  \verb|uint256 identifier, uint256 amount}|.$$
The \verb|Loan| structure contains the data of the assets flow {\it to or from the Vault} \footnote{In case of flow towards the Vault, the lender of the loan is the user.} for a given token, registering the eventual margin posted by the user, the interest rate and risk spread applied (these two are packed in a single integer to save gas).

The \verb|Collateral| structure contains the data of the assets {\it locked as collateral} to the Loan given or taken. This specifies the \verb|ItemType|, which currently can be ERC20, ERC721 or ERC1155, the token address, the identifier (only applicable for the ERC721 item type) and the amount.

\subsubsection{Functions}
The public functions of the Service contract are all \verb|virtual| and overridden by the inheriting Contracts, and they are the following:
\begin{itemize}
\item \verb|open(Order order)|: mints an NFT to the user, performs an internal abstract \verb|_open| function, implemented on a derived contract (see later subsections), and stores the resulting Agreement in the \verb|agreements| with a particular index. The \verb|Order| is a data structure containing the desired Agreement together with additional \verb|data| to adjust to the particular implementation of the Service.
\item \verb|close(uint256 index, bytes data)|: burns the relative NFT from the user, performs an internal abstract \verb|_close| function, and deletes the corresponding Agreement from the \verb|agreements|. The \verb|data| paarameter allows to adjust to the particular implementation of the Service.
\item \verb|edit(uint256 index, Agreement agreement, bytes data)|: allows the owner of the NFT to change the existing Agreement in the \verb|agreements| into the new one \verb|agreement|. The \verb|data| parameter allows to adjust to the particular implementation of the Service. Currently it is fully virtual, not implemented in the Base Service.
\end{itemize}

\subsection{Debit Service}\label{debitServiceSub}
The {\bf Debit Service} is the prototype of a Smart Contract calling (through the Manager) the \verb|borrow| and \verb|repay| functions of the Vaults. Since it still does not have a precise implementation, the contract definition is as follows:
$$\verb|abstract contract DebitService is Service {...| $$
It does not have any native storage (beyond the one inherited by the Service contract). The functions are both contract specific and overridden ones.

The {\bf overridden function} are as follows:
\begin{itemize}
\item \verb|open(Order order)|: updates the \verb|exposures| by adding the Loan's \verb|amount|, transfers the Loan's \verb|margin| from the caller (in particular, the caller must approve the contract beforehand), and borrows the Loan's \verb|amount| by calling the Manager's \verb|borrow| function. Finally, it calls the overlying \verb|open| function.
\item \verb|close(uint256 index, bytes data)|: calls the overlying \verb|close| function, updates the exposures by subtracting the loan amounts, and repays the Vault by calling the Manager's \verb|repay| function. A modifier enforces that the caller must be the owner of the NFT with that index, unless the Agreement is liquidable (see below).
\end{itemize}

The {\bf specific functions} take into account the {\it default risk} of the borrowing procedure, which is mitigated through liquidation:
\begin{itemize}
\item \verb|quote(Agreement agreement)|, a virtual function without implementation, is aimed to compute the amount of tokens obtained in a \verb|close| call done in that specific moment.
\item \verb|liquidationScore(uint256 id)| a virtual function computing a number which determines the "health" of the position by considering the Loan of \verb|agreements[id]| and calling the \verb|quote| function. By default, the Agreement is {\it liquidable} if its liquidation score is positive: in this case, anybody can close the Agreement by calling the \verb|close| function. The precise calculation uses the {\bf liquidation threshold}:
$$LT = L + M\cdot \frac{S}{I+S}$$ where $L$ is the loan amount, $M$ is the margin, $S$ is the risk spread and $I$ is the interest rate applied to that particular agreement. The liquidation score is then $$LS = \left(1 - \frac{Q}{LT}\right)_+$$ where $Q$ is the quoted amount.\footnote{In order to avoid rounding and normalization errors, this quantity is a dimensionless 18 digit fixed point integer.} This formula is valid for a single token loan: the liquidation score of a multi-token loan is the sum of the single liquidation scores for each token.
\end{itemize}

\subsection{Securitisable Service}\label{securitisableServiceSub}
In traditional finance, {\bf securitisation} is the process of selling a particular asset or basket of assets under management to a willing investor who takes their risk and rewards.

In our implementation, a {\bf Securitisable Service} is a Debit Service whose credit, which initially belongs to the Vault, can be freely {\it purchased} by directly repaying the Vault at a discount. This has actually the effect of changing the {\it lender}: that's why the contract has a storage state variable
$$\verb|mapping(uint256 => address) lenders|$$
who associates, for each index, the address of the lender who purchased the credit.

The Contract definition is defined as
$$\verb|abstract contract SecuritisableService is DebitService {...| $$

and it consists of:
\begin{itemize}
\item  The specific function \verb|purchaseCredit(uint256 id)|, which computes the {\bf fair price} of the credit coming from the Agreement with \verb|id| index and repays the Vault via a call to the Manager's \verb|repay| function and stores the purchaser into the \verb|lenders| storage variable. It also decreases the \verb|exposures| accordingly. The fair price is calculated as $$FP =  L + F\cdot\frac{S}{I+S}$$ where $L$ is the loan amount, $F$ are the fees accrued so far, $S$ is the risk spread and $I$ is the interest rate applied to that particular agreement.
\item The overridden function \verb|close| checks whether a given lender has been initialized: in this case, the repay is done to the lender via a direct transfer, rather than through a \verb|repay| call.
\end{itemize}

\subsection{Credit Service}\label{creditServiceSub}
The {\bf Credit Service} is the prototype of a Smart Contract calling (through the Manager) the \verb|directMint| and \verb|directBurn| functions of the Vault. In order to be able to have this privilege, the user must deposit some liquidity to the Vault, therefore these services can be considered as a loan given {\it by the user to the Vault} (that is, the user acquires a credit, rather than a debit, towards the Vault).

The definition of this contract is 
$$\verb|abstract contract CreditService is Service {...| $$
and it only consists of two overridden functions:
\begin{itemize}
\item \verb|open| calls the overlying open function, calls the \verb|deposit| ERC4626 function of the Vault and updates the \verb|exposures| with the obtained shares.
\item \verb|close| calls the overlying close function and updates the \verb|exposures|.
\end{itemize}
Since the exit from credit Agreements can be of various types (see the {\it multiple exit scenarios} in \ref{csFirstSec}), we do not assume a \verb|withdraw| is called at exit, and leave the specific implementaiton to the inheriting contracts.

\subsection{Whitelisted Service}\label{whitelistedServiceSub}
In {\bf Whitelisted Services}, the Governance maintains a mapping
$$\verb|mapping(address=>bool) whitelisted|$$
which checks whether a given user is whitelisted or not. Only whitelisted users can access to such services if the \verb|enabled| flag is set to true, and this is enforced by implementing the \verb|_beforeOpening| hook.
The definition of this contract is 
$$\verb|abstract contract WhitelistedService is Service {...| $$
in particular, implementations of any of the types of services described above (Debit, Credit, Securitised) may or may not inherit from Whitelisted.

\section{Fees}\label{feesSec}
Ithil's core, as discussed in the previous sections, does not have any implementation of fees, and instead leaves to the single Service implement the most suitable fee structure. These structures are implemented in separate contracts which are inherited by the particular Service. For example, if a particular ParticularService, which is a Securitisable, Whitelisted DebitService, needs to adopt the fee model implemented in the FixedFee contract, its definition would be
$$\verb|ParticularService is Securitisable, Whitelisted, FixedFee {...| $$
We will not deep dive here into the particular fee models currently implemented by Ithil's development team, nor of the countless existing in the various Web3 protocols. However, given that we encountered Debit Services, which borrow assets from the Vault, it is clear that such services need to have an {\bf base interest rate} $B$ and a {\bf risk spread} $S$ to account for the cost of borrowing. The sum of these two number gives the total interest rate $I = B + S$ of an Agreement.

When an Agreement is closed, the fees to pay are thus calculated as $$F = L * I * (t - t_0) $$ where $F$ are the fees, $L$ is the loan taken, $I$ is the interest rate applied, $t_0$ is the time the Agreement was created at, and $t$ is the current time. All fees are transferred to the Vaults during the call to \verb|repay|.

\subsection{Base Interest rate}\label{interestRateSubSec}
The base interest rate is a number capturing the cost of borrowing capital from the Vault, considering the Vault's specific parameters such as utilization rate or token's volatility. In particular, it is not intended to capture the precise riskiness of the investment, but rather how much the lenders want to be paid to lend their assets.  Many interest rate models have been proposed in the Web3 world, while an example of a new one used by Ithil is the {\bf Auction Model}, which we will now illustrate.

We want to stress that, just like the case of Services, also the Interest Rates are important components in order for a contract to be whitelisted, but they are not part of Ithil's core: new interest rate models can be conceived by Services developers, and the current phylosophy is to design an architecture so to make future developments seamless, in an effort to make Ithil as dynamic and modular as possible. In particular, the following rate model is an {\it example} of what Ithil can support.

\subsubsection{Auction Rate Model}\label{auctionSubSub}
In this model, we want to capture both the Vault's usage (the less free liquidity, the higher the rate for the same loan) and the time passed after the last loan (the more time passes, the lower the rate for the same free liquidity and loan). In this way, the rate follows a {\it Dutch auction model} which naturally makes the interest rate go down if nobody asks for a loan, thus facilitating the creation of a market equilibrium between lenders and borrowers and increasing capital efficiency.

\begin{itemize}
\item By labelling the sequence of loans in time with $l_1, l_2, \ldots$ we have a corresponding sequence of base rates $b_1,b_2, \ldots$ and times $t_1, t_2, \ldots$
\item We have the recursive definition $$b_{i+1} = b_i \cdot \frac{FL}{FL-l_{i+1}}\cdot\frac{H}{H + t_{i+1} - t_i}$$ where $FL$ is the Vault's free liquidity and $H$ is a Governance chosen time parameter called {\bf halving time}. It can be interpreted as the time after $t_i$ which cuts the base rate exactly by half. Notice that, thanks to the fact that the entire free liquidity cannot be withdrawn as per ERC4626 health check, the denominator cannot be zero.
\item The new rate $b_{i+1}$ is calculated at the time a new loan is taken with the above formula, and it is stored in the Contract's state together with $t_{i+1}$
\end{itemize}

\subsection{Risk spread}\label{riskSpreadSubSec}

The risk spread is a fixed number, chosen by the Governance, representing the riskiness of a particular loan\footnote{This is called credit risk or default risk in traditional finance} and it is added to the base interest rate to calculate the "full" interest rate of an Agreement.

Therefore, we will have $$I = B + S$$ where $I$ is the interest rate, $B$ is the base interest rate as in Subsection \ref{interestRateSubSec}, and $S$ is the risk spread. It can be seen as the minimum rate, below which no Agreement can be opened for that particular Service and token.

For example, by looking at the Auction Model \ref{auctionSubSub}, we see that the base rate could also become zero after a very long time: there are no positive lower bounds to it. Therefore, the interest rate will converge to the risk spread with time.

\section{Automations}\label{automationsSec}
Each Service may have one or several {\bf automations}, that is actions which can be executed to change the Service state in a controlled way, independently on the opening and closing of each Agreement. Since this concept is rather abstract, we will illustrate some examples based on the Service structure described in the previous sections.
\subsection{Credit Services}\label{automationCreditSubSec}
As seen in \ref{creditServiceSub}, Credit Services can call a function using the Manager's \verb|directMint| or \verb|directBurn|, in exchange of a dedicated \verb|deposit| on the Vault. At any time, these functions can be called by anyone (who obtains a reward for doing so) to redistribute or slash assets to the users of the Service.
For example, the Insurance Reserve Service will call a \verb|directBurn| when a loss occurs, and a \verb|directMint| when a profit occurs (the latter is necessary to compensate the possibility of being slashed, and it has the effect of giving insurers a higher APY than the other lenders, in case no losses occur).

\subsection{Debit Services}\label{automationDebitSubSec}
The most important automation in Debit Services is clearly {\bf liquidation}, in which anybody can close an Agreement with positive liquidation score (see \ref{debitServiceSub}) and get a reward in doing so. This automation is so important that the Governance itself has a liquidation bot running on the whitelisted Services, although such bot has no edge with respect of any other player executing the same function. 

To give another example, many DeFi-style Debit Services consist in deploying liquidity into an external protocol who, in exchange, emits {\it spurious tokens}, i.e. tokens different from the ones in the Loan or Collateral part of the Agreement. Such tokens can then be swapped in batch to obtain loan tokens, which are distributed to the users. Such process, traditionally called {\bf harvesting} in DeFi, is very general and also applicable to non-DeFi Services as long as one action distributes extra value to the users. 
\end{document}
