\documentclass[a4paper,10 pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{}
\usepackage{amsmath, amssymb, amsthm}

% This is how I (Maciej) will make comments 
\usepackage[dvipsnames]{xcolor}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{problem}{Problem}

\newcommand{\tb}{\verb|TKB|}
\newcommand{\ta}{\verb|TKA|}

\theoremstyle{definition}
\newtheorem{remark}{Remark}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}

\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
            
        \Huge
        \textbf{Ithil}

        \vspace{0.5cm}
        \Large
        {\bf The Web3 Wizard}

        \vspace{1cm}
        \Large
        {\it Ithil is a financial interoperability layer that connects the whole web3 space facilitating new value creation via crowdlending.}

        \vspace{1.5cm}
        {\normalsize V2.0.1 - \today}
        \vspace{1.0cm}

        \begin{abstract}        
        Ithil aims to bring decentralised services to the web3 space via a well-thought system of undercollateralised loans - a game-changer for traders, liquidity providers, and other protocols who can now rely on various capital-efficient products to address their needs. 
        
        Modular and easily upgradable, Ithil offers users and other protocols easy interactions with the web3 space as a whole, enabling an entirely new range of financial opportunities. Liquidity is taken from liquidity providers (or Lenders), who can stake any whitelisted ERC20 token and get a high APY on that same token getting exposure to the ecosytem with a reduced risk. In fact, their capital is spread over several protocols and it is protected by an efficient liquidation system.
        \end{abstract}
            
    \end{center}
\tableofcontents
\end{titlepage}

\section{Introduction}

In the current Web3 space there are several opportunities, from DeFi high yields to NFTs and gaming, with new ones coming up almost every day. Users are shown a wide landscape to interact with, depending on their risk appetite and personal ideas. However, all the subspaces are set apart one another, and end up being self-contained bubbles that don't interact with each other: DeFi, NFTs, gaming and metaverse are all separate from each other and the composability of one another is still uncharted territory.

While for the lenders, the typical parameters LPs look for are a good APY, the market exposure (such as by holding volatile tokens), the underlying protocol's reliability and security, the liquidity available or TVL, their personal preferences and several other factors difficult to predict or model.
With Ithil they are presented a novel opportunity to get exposed to the high yields on the whole Web3 space in a combined way, reducing the overall risk as well as increasing the return rates on their deposits.

\subsection{What is Ithil}
%At its core, Ithil is a protocol that combines the liquidity providers' deposits to other protocols to create novel financial services for its users. In this way, Ithil can be considered as a {\it trait-d'union} between the many protocols existing in the space, users and liquidity providers.

At its core, Ithil is a protocol allowing {\it liquidity providers} to deposit their assets, and {\it users} to deploy such assets into external protocols within the Web3 world. Users need to protect the LPs' assets by placing some {\it collateral} and by paying {\it interests} on the deployed liquidity. 
In this way, LPs benefit of a very low risk and a solid return thanks to a high diversification and capital protection, while users are entitled to all earnings and services coming from the deployed assets.

\subsection{What can be done on Ithil}
With Ithil, anyone can
\begin{enumerate}
\item Become {\bf liquidity provider} (LP) by depositing their assets to get a solid APY. A extensive choice of whitelisted tokens can be staked in Ithil, and the APY generated is in the same token as the provided one. In this way, Ithil offers an attractive staking opportunity, also for holders of volatile tokens.
\item Boost their investments by placing some collateral and then using the LP liquidity on one of Ithil's whitelisted protocols (Aave, Uniswap, Balancer, OpenSea etc...). Thanks to an internal system of undercollateralised loans (the {\bf Internal Lending Engine}), the total capital deployed can be much higher than the collateral placed: by placing only 100 DAI worth of collateral, a user can deploy 1000 DAI worth of liquidity or more.
\item Be a {\bf liquidator} by constantly checking the losing positions and liquidating them in a fully on-chain way, thus getting high rewards.
\item Become a {\bf harvester} by performing farming or other maintenance duties on the strategies which require them, and getting a part of the harvest as a reward.
\item Join the {\bf community} by buying and holding Ithil's governance token, using it in the liquidation process or participating in governance voting. Ithil's innovative backing system ensures that Ithil's value mathematically increases in time, thus encouraging holders to commit to the community for a long time.
\end{enumerate}

\subsection{Ithil's unique features}
Many of Ithil's features are rarely found in the current web3 landscape. Some of the differences are the following:
\begin{itemize}
\item {\bf Modularity} allows Ithil to list or de-list virtually any service with a governance vote, hence, allowing Ithil to continuously be updated with the most recent protocols, always offering what is best and trending to the users, be it DeFi, Metaverse, Play to Earn or anything.
\item {\bf High capital efficiency} over-collateralisation has always been an essential aspect in DeFi loans, which reduces the possibility for users to boost their available funds.\footnote{Or makes this process very costly, mainly through the so-called {\it folding strategies} on money markets like Aave.} Thanks to a novel lending model, Ithil makes it possible to protect the loans with just the right amount of capital, thus allowing a completely new set of on-chain financial services.
\item {\bf Opportunity to stake virtually any token}: few protocols offer a single-sided APY on ideally any token, usually being restricted to stablecoins, big cap tokens like WBTC and WETH or the protocol native token. Ithil's lending vaults are instead token-agnostic: any ERC20 token can be whitelisted and staked and it generates APY in the same token.
\item {\bf Real-yield sustainable APY} even on stablecoins' vaults, thanks to sustainable treasury management and a non-dilutive boosting system.
\item {\bf Capital protection} for liquidity providers: an efficient liquidation model and an algorithmically-maintained insurance reserve protect the LPs' liquidity, thus assuring long-lasting earnings with limited risk exposure.
\item {\bf Solid tokenomics} thanks to an innovative services network, fees are used to buy back ITHIL tokens and to boost the vaults, attracting more liquidity and in turn more fees, in a positive feedback mechanism constantly bringing value to the protocol and to the token holders in a sustainable way. See Section \ref{servicesSec} for details. 
\end{itemize}

\subsection{Ithil's mission}
%Commitment to offering an easy and sustainable set of financial products and help users get the best out of them is the main focus of Ithil.
Ithil's main mission is to offer the broadest range of decentralized financial services for the Web3 world, and help users get the best out of them.

By interconnecting the several protocols existing in the subareas of web3, Ithil can create innovative investing opportunities (DeFi strategies), help users get what they want (on-chain mortgages) or simply enjoy the space better (access gated communities by renting NFTs).

Through capital boosting, Ithil wants to mitigate the intrinsic advantage of wealthy individuals, allowing small users to fully embrace the opportunities Web3 has to offer.

Building trust is of primary importance, especially in an ecosystem where scammers, Ponzi schemes, and ill-modelled backing systems are unfortunately too popular. Ithil commits to giving real value to the community: every surplus earned by the protocol is algoritmically injected into the boosting contract and can be used by anyone to buy back tokens, thus increasing the value of its token and the financial power of its treasury in a clear and sustainable way.

\newpage

\section{Core concepts}
This section summarises the inner workings of the protocol, which will be treated more in-depth in the following sections. 
\subsection{The Vaults}\label{vaultSub}
The {\bf Vaults} are ERC4626 smart contracts that collect liquidity to be used in services required by the users. The liquidity contained in each Vault is made of a {\bf whitelisted ERC20 token}, which can be in principle any token, from stablecoin to meme and rebasing tokens. The whitelisting process belongs to the governance.

{\bf Liquidity Providers (LPs)} can freely {\bf deposit} into the Vaults and {\bf withdraw} from them at any time. The Vault contract collects the fees generated by the Services, which increase the share price of the Vault's ERC4626 token thus yielding an APY to the LPs.

The Vaults {\bf lend} liquidity to the Debit Services (see \ref{debitSubSub}) and {\bf borrow} liquidity from the Credit Services (see \ref{creditSubSub}) via internal uncollateralised loans. Only the Router contract (see \ref{routerSub}) can execute borrowing and lending on behalf of a Vault.

\subsection{The Router}\label{routerSub}

The {\bf Router} is responsible for the general accounting and coordination between the Vaults and the Services. {\bf Users} can access the Services through the Router, which in turn transfers the Vaults' liquidity from or to the {\bf whitelisted Services} contracts. The whitelisting process belongs to the governance.

When a user accesses a Service, it is said that the user is {\bf entering an Agreement}. Similarly, by {\bf exiting an Agreement} the user restores the initial state of the Vaults plus fees.

In order to be able to access a Service, users may need to deposit a {\bf collateral} to cover for potential losses incurred by LPs, whose liquidity is borrowed or lended for the Service.

When liquidity is lent or borrowed, the Router calculates the {\bf interest rate} of the loan, based on parameters coming from the global state of Ithil's contracts (free liquidity, already lent and borrowed liquidity, insurance reserves, amount of collateral placed, risk factors etc...).

\subsection{Services}\label{servicesSub}

By {\bf Services} we mean a set of contracts, which allow {\bf users} to interact with the Web3 using their own and/or the Vaults' liquidity to perform a certain action. The services are broadly divided into {\bf Debit Services (DS's)} and {\bf Credit Services (CS's)} depending on whether the user wants to borrow or lend liquidity respectively.

When {\bf entering an Agreement}, the user gets an {\bf agreement NFT} which represents the user's entitlement in the service and the liquidity taken from, or given to, the Vaults. {\it The Router (see \ref{routerSub}) maintains the ownership of such NFT} until the LP loan it represents is extinguished. See \ref{posNftSubSub} for further details about agreement NFTs.

When {\bf exiting an agreement}, all the loans are extinguished and the due fees are paid to the Vaults, and the agreement NFT is burned. The user keeps any other assets remaining after the closure.

See \ref{servicesSec} for real examples of supported Services and Targets.
\subsubsection{Debit Services}\label{debitSubSub}
A {\bf Debit Service} is a contract which triggers a loan {\it from a Vault} and deploys the obtained liquidity into some other contract called {\bf Target} (see \ref{targetsSub}). These targets are typically, but not necessarily, outside of Ithil's echosystem and some examples are Balancer, Aura, Uniswap, Yearn, etc...

\subsubsection{Credit Services}\label{creditSubSub}
A {\bf Credit Service} is a contract which triggers a loan {\it to a Vault} and deploys the obtained ERC4626 token into some other contract called {\bf Target} (see \ref{targetsSub}). These targets are typically, but not necessarily, within Ithil's echosystem and some examples are Ithil's Booster, Insurance Reserves, ITHIL Call and Put Options, etc...

\subsubsection{Agreement NFT}\label{posNftSubSub}

Every time a user enters a service, a {\bf agreement NFT} keeping the state of the service is minted to the user. The precise state depends on the particular service it refers to, but all services have common parameters:
\begin{itemize}
\item The {\bf owner}, i.e. the address of the user entering the service.
\item The service {\bf type} (Debit or Credit).
\item The {\bf collateral} amount.
\item The loan amount, called {\bf principal}.
\item The amount of assets locked in the service, called {\bf allowance}.
\item The {\bf interest rate} of the loan taken or given.
\item The {\bf timestamp} of the entry time.
\item The {\bf target address}.
\item Some {\bf extra parameters} depending on the particular service.
\end{itemize}

The agreement NFT is transferred to the user's wallet, but the Router keeps the ownership of agreement NFT.

\subsubsection{Quoter}\label{quoterSubSub}
Every service has its own {\bf quoter} contract, which is a smart contract in charge of the evaluation of each agreement NFT. It is developed and linked to the service by the governance, and each service has one and only one quoter.

By {\it evaluation} we mean the amount of Vault's tokens the user can obtain when exiting the agreement in that particular moment; this number is called the {\bf value} of the agreement NFT. This includes the Target's payoff in that moment and the  The value is used to compute the {\bf liquidation score} of a agreement NFT: if the liquidation score becomes positive, the {\bf liquidators} (see \ref{liquidatorSub}) can trigger a special function of the Router to forcefully exit the position and close the loan. An extra fee is then charged to the user in order to compensate the liquidators.

\subsection{Fees}\label{feeSub}

Agreements may or may not have {\bf fees} attached. The fees are always deposited to a Vault and contribute to the appreciation of the ERC4626 tokens representing the Vault.  All fees are paid when an agreement is {\it exited}.

The particular fee structure of a particular agreement depend on the Service it refers, but in general we can distinguish between three kind of fees.


\subsubsection{Interest rate}\label{interestRateSubSub}
When liquidity is borrowed from a Vault, an {\bf interest rate} is attached to the loan. Calculation of the interest rate is done by the {\bf interest rate library} and the result depends on the global state of Ithil contracts. As a general rule, the interest rate increases with the Vault usage, with the risk factor of the Service, and on the overall amount of liquidity already locked in that Service, while it decreases with the amount of user's collateral and with time if nobody borrows (as in a Dutch auction scheme). The proportionality coefficients are decided by the governance, therefore the actual determination of the interest rate is mixed algorithmic-governance.

\subsubsection{Fixed fees}\label{fixedFeesSubSub}
When a service is accessed, a {\bf fixed fee} might be charged to enter the Agreement. This fee may or may not depend on the amount of collateral posted or liquidity loaned. The fixed fees are decided by the governance.

\subsubsection{Performance fees}\label{fixedFeesSubSub}
Some Services (typically finance-related ones) may have a {\bf performance fee}, that is it may require that a percentage of the user's gain goes to the Vault.

\subsection{Targets}\label{targetsSub}

By {\bf Target} we mean any contract to which borrowed or lent liquidity is deployed. Targets, which can be either external or internal to Ithil's echosystem, represent the way users can use Ithil to access external services with more liquidity than their original, or internal services to get extra benefits from lending their liquidity to Ithil. See \ref{servicesSec} for real examples of supported Services and Targets.

\subsection{Automators}\label{automatorsSub}

{\bf Automators} are external players which perform various tasks in order to optimize the outcome of each Service, and get rewards by doing this. Everybody can be an automator and there is no entry cost nor staking requirement, since Ithil considers the automators' actions as beneficial to the echosystem. 

Conceptually, we can divide automators into liquidators and harvesters.

\subsubsection{Liquidators}\label{liquidatorSubSub}
A {\bf liquidator} is anybody who makes an agreement with positive {\bf liquidation score} to be forcefully exited. In this case, the liquidator becomes the owner of the agreement and gets the remaining funds within the agreement NFT as a reward. In case no liquidity is left into the NFT, other Services, whose liquidity is allocated on purpose for these events, provide the necessary reward. In this way, liquidators assure the loans are repaid in the best way as possible: even in the case a loss is inevitable, liquidation will minimize it.

\subsubsection{Harvesters}\label{harvesterSubSub}
A {\bf harvester} is anybody who triggers special functions to improve the performance of a Service, and it is always rewarded using part of the extra value given to the Service. 

This abstract definition is better explained with examples (see Section \ref{servicesSec} for further details on these examples): the ``Balancer + Aura" Service needs Aura harvesting to increase the Service overall APY, and the harvester is rewarded with part of the extra liquidity given by Aura; the ``Boosting" strategy needs continuous minting or burning of Vault's tokens to rebalance the Service value, and the harvester is rewarded with part of such tokens.

The precise properties of harvesting greatly vary from Service to Service, and it can be considered as part of the Service itself outside the user's Agreement.

\section{Examples of Services}\label{servicesSec}

Examples of Services, with the respective Targets, and the way they are used are the following.

\subsection{Debit services}
These services are characterized by liquidity that goes {\it from} the Vault {\it to} the particular service. In this case the Vault issues a loan to the Service by transferring the liquidity to the Service smart contract, which then locks any asset obtained. This loan is repaid when the agreement is exited.

\begin{itemize}
\item {\bf Yearn}. Liquidity is taken from a Vault and deployed on Yearn; the resulting y-Tokens are then locked into the resulting agreement NFT. At the exit, the service's y-Tokens are redeemed on Yearn to repay the loan from the Vault.

\item {\bf Balancer + Aura}. Liquidity is taken from a Vault and deployed on a Balancer pool; the resulting BP-Tokens are then deployed on Aura and the resulting liquidity entitlement is given to the agreement NFT address. During the service's life, harvesters (see \ref{harvesterSub}) collect the Aura rewards and fill (via a reflaction) all open agreement NFT's. At the exit, the BP-Tokens are unstaked from Aura and redeemed on Balancer to repay the loan from the Vault.

\item {\bf Uniswap V3}. Liquidity is taken from one or two Vaults and deployed within a price range on Uniswap V3. The resulting UniV3 NFT is then locked into Ithil's agreement NFT. At the exit, the liquidity and generated fees are withdrawn from Uniswap NFT and the loan to the Vault is repaid.

\item {\bf OpenSea}. Liquidity is taken from a Vault to purchase an NFT from OpenSea, which is then locked into the agreement NFT. In order to keep the position open, the user must regularly inject liquidity into the Vault to partially repay the loan. At the exit, the loan is fully repaid and the original NFT is transferred to the user.
\end{itemize}
\subsection{Credit services}

These services are characterized by liquidity that goes {\it to} the Vault {\it from} the particular service. In this case the User provides the liquidity to the Service smart contract, which then transfers it to the Vault and gets the resulting Vault's token. The token is then used for the Service particular functionalities and it is redeemed to the Vault when the agreement is exited.

\begin{itemize}
\item {\bf Boosting}. Liquidity is deposited into a Vault and the resulting ERC4626 are redirected into Ithil's boosting Service. Harvesters (see \ref{harvesterSubSub}) periodically transfer part of the Vault's accrued fees into the Service, and if ERC4626 collateralization decreases, harvesters restore the boosters' total value by minting extra Vault's tokens (this means that the boosters are {\it senior} with respect to regular LP, and they are accepting a lower APY in return of a lower risk). When the agreement is exited, the relative ERC4626 tokens are redeemed.

\item {\bf Insurance}. Liquidity is deposited  into a Vault and the resulting ERC4626 are redirected into Ithil's insurance Service.  Harvesters (see \ref{harvesterSubSub}) periodically transfer part of the Vault's accrued fees (a larger part than the Boosting case) into the Service,  and if ERC4626 collateralization decreases, harvesters restore the Vault's total value by burning some Vault's tokens  (this means that the insurers are {\it junior} with respect to regular LP, and they are accepting a higher risk in return of a higher APY). When the agreement is exited, the relative ERC4626 tokens are redeemed.

\item {\bf LP'ing}. Regular LP'ing can be considered a "trivial" Credit Service, with intermediate seniority between Boosters (senior) and Insurers (junior).

\item {\bf ITHIL call options}. Liquidity is deposited  into a Vault and the resulting ERC4626 are redirected into Ithil's call option Service. This gives the right to buy a certain amount of ITHIL tokens at a given price (the {\it strike}) at a certain moment in the future (the {\it expiration date}). Both the strike and the expiration date are algorithmically computed. At the exit, the user can choose whether to buy or not the tokens, and depending on this choice either ITHIL or the original Vault's token is transferred to the user. This is an example of a Service with {\it multiple exit scenarios}.

\item {\bf ITHIL put options}. As in the previous case, but now the user has the right to {\it sell} ITHIL tokens at a given price (the {\it strike}) at a certain moment in the future (the {\it expiration date}). Both the strike and the expiration date are algorithmically computed.
\end{itemize}

\newpage
\section{The Vaults}\label{vaultSec}

We now look more deeply into the technical specifications of Ithil's Vaults. As mentioned in \ref{vaultSub}, the Vault is yield bearing token following the ERC4626 standard, and its purpose is collecting all liquidity deposited by LP's and Credit Services, and lending this liquidity to Debit Services.

First of all, the Vault inherits from ERC4626 and from OpenZeppelin's Ownable contract:
$$ \verb|contract Vault is ERC4626, Ownable| \  \ \{ \verb|...| \}$$
We will not dig down into ERC4626 and Ownable's contract specification and redirect the interested reader into the respective contracts' documentations.

We will instead talk about Ithil's overrides to the inherited ERC4626 functions and Ithil's specific functions.

\subsection{Accounting}\label{accountingSub}
The Vault keeps three state variables for accounting: 
$$ \verb|uint256 netLoans|, \ \ \verb|int256 currentProfits|, \ \ \verb|uint256 latestRepay|$$
The variable \verb|netLoans| registers the total amount of loans given across all Debit Services, while \verb|currentProfits| the total {\it locked} profits at the moment of the latest repay. The block's timestamp of the latest repay is registered into \verb|latestRepay|.

\subsection{Locking}\label{lockingSub}
Fees and losses (see \ref{repaySub}) undergo a locking period to dampen the movements of the Vault's token price per share. The locked fees are computed via the \verb|calculateLockedProfits()| function, whose formula is
$$L = P\cdot\frac{\max(T_L+T_U-T),0)}{T_U} $$
where $L$ is the result of the function, $P$ is the \verb|currentProfits|, $T_U$ is the Vault's \verb|unlockTime|, a governance-decided variable initialized at 6 hours, $T_L$ is the \verb|latestRepay| and $T$ is the current block's timestamp.

In particular, when $T = T_L$, that is at the moment of profit (or loss) generation, we have $L = P$ and all \verb|currentProfits| are locked. After the locking period, that is $T \ge T_L + T_U$, we will have $L=0$ so all fees are unlocked. For $T_L \le T \le T_L + T_U$, we simply have $$L = P\cdot\left(1- \frac{T - T_L}{T_U} \right)$$ meaning that the fees and the losses unlock {\it linearly} with time.

\subsection{Total Assets}\label{totalAssetsSub}

Both borrowing from the Vault and repaying would modify the value of \verb|totalAssets| as defined in the original ERC4626 contract and the resulting token price per share. Since loans are just temporarily moved from the vault, and since fees need to undergo a locking period, we need to factor this in into the definition of total assets. Therefore we have $$\verb|totalAssets| = \verb|super.totalAssets + netLoans - calculateLockedProfits()|$$ with the use of mathematical overflow and capping checks so that to always make \verb|totalAssets| $> 0$ and never make the above computation overflow (this is the recommended ERC4626 standard for overriding this function).

\subsection{Free Liquidity}\label{freeLiquidity}

The Free Liquidity is the amount of liquidity that can be freely borrowed or withdrawn. Of course, it would be impossible to transfer an amount higher than the Vault's native token balance, but also locked profits should not be available for borrowing or withdrawal. Therefore, letting $L = \verb|calculateLockedProfits()|$ we define
$$\verb|freeLiquidity| = \begin{cases}
\verb|native.balanceOf(vault)| - L &\text{ if } L > 0 \\

\verb|native.balanceOf(vault)| &\text{ otherwise}.
\end{cases} $$

An important caveat is that {\it the entirety of the free liquidity cannot be borrowed or withdrawn at once}. Indeed, this could cause the Vault to become {\bf unhealthy} as per ERC4626 standard. Therefore, the functions \verb|borrow|, \verb|withdraw| and \verb|redeem| have a check so to revert if the entirety of the free liquidity is taken. 
\subsection{Borrow}\label{borrowSub}

The Vault's \verb|borrow(amount, receiver)| function is an only-owner function which directly transfers \verb|amount| of the native asset from the Vault to a \verb|receiver|. In order to register the loan, the \verb|netLoans| state variable is incremented by \verb|amount|. In practice, the receiver will be one of the whitelisted Debit Services, as the Router is in control of the list of receivers.

In order to insure the Vault is {\it healthy} as per ERC4626 standard (this means that the Vault's balance cannot be zero if the Vault's supply is higher than zero),  the \verb|amount| must be {\it strictly less} than the Vault's {\it free liquidity}.

The typical use case is liquidity lent to a Debit Service contract in order to make a user enter an Agreement.

\subsection{Repay}\label{repaySub}

The Vault's \verb|repay(assets, debt, repayer)| function is an only-owner function which directly transfers \verb|assets| of the native asset from the \verb|repayer| to the Vault. The \verb|debt| is the amount of loan this function is declared to repay: the \verb|netLoans| state variable is decremented by \verb|debt| within this function.

The parameter \verb|assets| can be either larger or smaller than \verb|debt|. In the former case, we say that the difference \verb|assets - debt| is the {\bf fees} paid to the Vault for lending its liquidity; in the latter case, we say that the difference \verb|debt - assets| is the {\bf loss} incurred by the Vault for lending its liquidity. We call the former case a {\bf Good Repay Event (GRE)} and the latter case a {\bf Bad Repay Event (BRE)}. 

Both the fees and the losses undergo a {\bf locking period} which protects the Vault from flashloaners draining all the incoming fees and disincentivize LPs to frontrun losses. In order to do this, the \verb|currentProfits| and \verb|latestRepay| variables are updated as 
$$\verb|currentProfits| \mapsto \verb|calculateLockedProfits() + assets - debt|$$ 
$$\verb|latestRepay| \mapsto \verb|block.timestamp|$$ 
Notice that \verb|currentProfits| increases in a GRE and decreases in a BRE and that although this variable can become negative, a BRE may not be sufficient to make it negative if the current locked profits are large enough. Conversely, a high enough GRE can make positive a formerly negative \verb|currentProfits|.

As per ERC4626 standards, a positive \verb|currentProfits| will tend to increase the Vault's token price per share, while a negative one will tend to decrease it.

This function is called every time an Agreement for a Debit Service is exited.

\subsection{Direct mint}\label{directMint}
Via \verb|directMint(shares,receiver)| the Router can directly mint \verb|shares| of the Vault's ERC4626 tokens to the \verb|receiver|. In practice, the receiver will be one of the whitelisted Credit Services, as the Router is in control  of the list of receivers.

This function has the effect of decreasing the Vault's price per share, while distributing part of the Vault's assets to the receiver by reflection. In that sense, it is considered a {\it loss} for the Vault and as such it needs to undergo the usual locking period. In order to calculate the loss, we use the native ERC4626 \verb|convertToAssets| function and update 
$$\verb|currentProfits| \mapsto \verb|calculateLockedProfits() - convertToAssets(shares)|$$ 
$$\verb|latestRepay| \mapsto \verb|block.timestamp|$$

The typical use case of this function is the distribution of part of the accrued fees to a Credit Service.

\subsection{Direct burn}\label{directBurn}
Via \verb|directBurn(shares,owner)| the Router can directly burn \verb|shares| of the Vault's ERC4626 tokens to the \verb|owner|. In practice, the owner will be one of the whitelisted Credit Services, as the Router is in control of the list of owners.

This function has the effect of increasing the Vault's price per share, while distributing part of the owner's assets to the Vault by reflection. In that sense, it is considered a {\it profit} for the Vault and as such it needs to undergo the usual locking period. In order to calculate the profit, we use the native ERC4626 \verb|convertToAssets| function and update 
$$\verb|currentProfits| \mapsto \verb|calculateLockedProfits() + convertToAssets(shares)|$$ 
$$\verb|latestRepay| \mapsto \verb|block.timestamp|$$

The typical use case of this function is the return of part of the accrued fees from a Credit Service to the Vault.


\end{document}